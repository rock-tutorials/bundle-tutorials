require 'models/actions/fence_monitor'
module Tutorials
  # Define a fault response table to move back to origin when the
  # system crosses the virtual fence
  class Fence < Roby::Coordination::FaultResponseTable
    # Define the threshold for reached-origin
    argument :origin_reached_threshold, :default => 10
    # Define the fence size. Since it has a default value
    # in the FenceMonitors table, we don't have to pass it
    argument :fence_size, :default => 5
    # Import the definitions from the profile
    use_profile Tutorials::RocksWithTransformer
    # Declare our data monitors. The table's fence_size
    # argument is set from the fence_size argument of this
    # table
    use_data_monitoring_table FenceMonitors,
      :fence_size => fence_size

    # While not strictly necessary, it is a good policy to create
    # separate actions for the response steps. The fault response
    # handlers themselves should really be small
    describe('move back towards origin').
      required_arg('threshold', 'threshold in meters')
    action_script 'move_to_origin' do
      # Define our go-to-origin task in the same way than in
      # the action state machine. Simply replace #state with #task
      origin = task to_origin_def.use(rock1_dev)
      origin.monitor('done', origin.rock_child.pose_samples_port, :threshold => threshold).
        trigger_on do |pose|
          pose.position.x.abs < threshold &&
            pose.position.y.abs < threshold
        end.
        emit origin.success_event

      # Start it and wait for it to end
      execute origin
      # We're done
      emit success_event
    end

    # Fault handler for faults generated by
    # the fence_crossed monitor.
    on_fault fence_crossed_monitor do
      # Go back to the origin (finally !)
      execute task(move_to_origin(:threshold => origin_reached_threshold))
      # And restart whatever we were doing
      try_again
    end
  end
end

